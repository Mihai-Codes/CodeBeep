"""Command handlers for codebeep."""

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from codebeep.bot import CodeBeepBot

logger = logging.getLogger(__name__)


@dataclass
class CommandResult:
    """Result of a command execution."""

    success: bool
    message: str
    data: dict[str, Any] | None = None


class Command(ABC):
    """Base class for commands."""

    name: str
    description: str
    usage: str
    aliases: list[str] = []

    @abstractmethod
    async def execute(self, bot: CodeBeepBot, args: str) -> CommandResult:
        """Execute the command.

        Args:
            bot: The bot instance
            args: Command arguments

        Returns:
            Command result
        """
        pass


class BuildCommand(Command):
    """Execute a coding task with full access."""

    name = "build"
    description = "Execute a coding task with full access to modify files"
    usage = "/build <task description>"
    aliases = ["b", "do", "code"]

    async def execute(self, bot: CodeBeepBot, args: str) -> CommandResult:
        if not args.strip():
            return CommandResult(
                success=False,
                message="Please provide a task description.\nUsage: /build <task>",
            )

        try:
            # Create or get active session
            session = await bot.get_or_create_session()

            # Send message with build agent
            await bot.opencode.send_message_async(
                session_id=session.id,
                content=args,
                agent="build",
            )

            return CommandResult(
                success=True,
                message=f"Task started with build agent.\nSession: {session.id[:8]}...\n\nI'll notify you when it's complete.",
                data={"session_id": session.id},
            )
        except Exception as e:
            logger.exception("Failed to execute build command")
            return CommandResult(
                success=False,
                message=f"Failed to start task: {e}",
            )


class PlanCommand(Command):
    """Analyze and plan without making changes."""

    name = "plan"
    description = "Analyze code and plan changes without modifying files"
    usage = "/plan <analysis request>"
    aliases = ["p", "analyze", "review"]

    async def execute(self, bot: CodeBeepBot, args: str) -> CommandResult:
        if not args.strip():
            return CommandResult(
                success=False,
                message="Please provide an analysis request.\nUsage: /plan <request>",
            )

        try:
            session = await bot.get_or_create_session()

            await bot.opencode.send_message_async(
                session_id=session.id,
                content=args,
                agent="plan",
            )

            return CommandResult(
                success=True,
                message=f"Analysis started with plan agent.\nSession: {session.id[:8]}...\n\nI'll notify you when it's complete.",
                data={"session_id": session.id},
            )
        except Exception as e:
            logger.exception("Failed to execute plan command")
            return CommandResult(
                success=False,
                message=f"Failed to start analysis: {e}",
            )


class StatusCommand(Command):
    """Check current task status."""

    name = "status"
    description = "Check the status of current tasks"
    usage = "/status"
    aliases = ["s", "st"]

    async def execute(self, bot: CodeBeepBot, args: str) -> CommandResult:
        try:
            statuses = await bot.opencode.get_session_status()

            if not statuses:
                return CommandResult(
                    success=True,
                    message="No active sessions.",
                )

            lines = ["**Session Status:**\n"]
            for session_id, status in statuses.items():
                emoji = {
                    "idle": "ðŸ’¤",
                    "running": "ðŸ”„",
                    "waiting": "â³",
                }.get(status.status, "â“")

                lines.append(
                    f"{emoji} `{session_id[:8]}...` - {status.status}"
                    + (f" ({status.agent})" if status.agent else "")
                )

            return CommandResult(
                success=True,
                message="\n".join(lines),
            )
        except Exception as e:
            logger.exception("Failed to get status")
            return CommandResult(
                success=False,
                message=f"Failed to get status: {e}",
            )


class SessionsCommand(Command):
    """List all sessions."""

    name = "sessions"
    description = "List all OpenCode sessions"
    usage = "/sessions"
    aliases = ["ls", "list"]

    async def execute(self, bot: CodeBeepBot, args: str) -> CommandResult:
        try:
            sessions = await bot.opencode.list_sessions()

            if not sessions:
                return CommandResult(
                    success=True,
                    message="No sessions found.",
                )

            lines = ["**Sessions:**\n"]
            for session in sessions[:10]:  # Limit to 10
                title = session.title or "Untitled"
                lines.append(f"â€¢ `{session.id[:8]}...` - {title}")

            if len(sessions) > 10:
                lines.append(f"\n... and {len(sessions) - 10} more")

            return CommandResult(
                success=True,
                message="\n".join(lines),
            )
        except Exception as e:
            logger.exception("Failed to list sessions")
            return CommandResult(
                success=False,
                message=f"Failed to list sessions: {e}",
            )


class AbortCommand(Command):
    """Stop the current task."""

    name = "abort"
    description = "Stop the current running task"
    usage = "/abort [session_id]"
    aliases = ["stop", "cancel"]

    async def execute(self, bot: CodeBeepBot, args: str) -> CommandResult:
        try:
            session_id = args.strip() if args.strip() else None

            if session_id is None:
                # Find running session
                statuses = await bot.opencode.get_session_status()
                running = [sid for sid, status in statuses.items() if status.status == "running"]
                if not running:
                    return CommandResult(
                        success=False,
                        message="No running tasks to abort.",
                    )
                session_id = running[0]

            await bot.opencode.abort_session(session_id)

            return CommandResult(
                success=True,
                message=f"Aborted session `{session_id[:8]}...`",
            )
        except Exception as e:
            logger.exception("Failed to abort session")
            return CommandResult(
                success=False,
                message=f"Failed to abort: {e}",
            )


class ModelCommand(Command):
    """Switch AI model."""

    name = "model"
    description = "Switch the AI model"
    usage = "/model <model_name>"
    aliases = ["m"]

    async def execute(self, bot: CodeBeepBot, args: str) -> CommandResult:
        if not args.strip():
            # List available models
            return CommandResult(
                success=True,
                message=(
                    "**Available models:**\n"
                    "â€¢ `claude-opus-4.5` - Most capable\n"
                    "â€¢ `claude-sonnet-4.5` - Fast and capable\n"
                    "â€¢ `gemini-3-pro-high` - Google's best\n"
                    "â€¢ `gemini-3-flash` - Ultra fast\n\n"
                    "Usage: /model <name>"
                ),
            )

        model = args.strip()
        bot.current_model = model

        return CommandResult(
            success=True,
            message=f"Switched to model: `{model}`",
        )


class HelpCommand(Command):
    """Show help information."""

    name = "help"
    description = "Show available commands"
    usage = "/help [command]"
    aliases = ["h", "?"]

    async def execute(self, bot: CodeBeepBot, args: str) -> CommandResult:
        if args.strip():
            # Help for specific command
            cmd_name = args.strip().lower()
            cmd = bot.commands.get(cmd_name)
            if cmd is None:
                # Check aliases
                for c in bot.commands.values():
                    if cmd_name in c.aliases:
                        cmd = c
                        break

            if cmd is None:
                return CommandResult(
                    success=False,
                    message=f"Unknown command: {cmd_name}",
                )

            aliases = f" (aliases: {', '.join(cmd.aliases)})" if cmd.aliases else ""
            return CommandResult(
                success=True,
                message=f"**/{cmd.name}**{aliases}\n\n{cmd.description}\n\nUsage: `{cmd.usage}`",
            )

        # General help
        lines = ["**codebeep Commands:**\n"]
        for cmd in bot.commands.values():
            lines.append(f"â€¢ `/{cmd.name}` - {cmd.description}")

        lines.append("\n\nUse `/help <command>` for more details.")

        return CommandResult(
            success=True,
            message="\n".join(lines),
        )


class AgentsCommand(Command):
    """List available agents."""

    name = "agents"
    description = "List available OpenCode agents"
    usage = "/agents"
    aliases = ["a"]

    async def execute(self, bot: CodeBeepBot, args: str) -> CommandResult:
        try:
            agents = await bot.opencode.list_agents()

            if not agents:
                return CommandResult(
                    success=True,
                    message="No agents available.",
                )

            lines = ["**Available Agents:**\n"]
            for agent in agents:
                name = agent.get("name", "unknown")
                desc = agent.get("description", "No description")
                lines.append(f"â€¢ **{name}** - {desc}")

            return CommandResult(
                success=True,
                message="\n".join(lines),
            )
        except Exception as e:
            logger.exception("Failed to list agents")
            return CommandResult(
                success=False,
                message=f"Failed to list agents: {e}",
            )


# Registry of all commands
ALL_COMMANDS: list[type[Command]] = [
    BuildCommand,
    PlanCommand,
    StatusCommand,
    SessionsCommand,
    AbortCommand,
    ModelCommand,
    HelpCommand,
    AgentsCommand,
]
